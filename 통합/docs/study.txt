raw의 정체
raw = self._serial_port.read(5)  # 시리얼에서 5바이트 읽음
# raw = b'\x8e\xd6B\xf4\x08'  (예시)

##raw는 5바이트 배열:
raw[0] = 0x8E  # 142
raw[1] = 0xD6  # 214  
raw[2] = 0x42  # 66
raw[3] = 0xF4  # 244
raw[4] = 0x08  # 8
```

### **각 바이트의 의미**
```
┌─────────────────────────────────────────────────────┐
│             RPLidar 스캔 데이터 (5 bytes)            │
└─────────────────────────────────────────────────────┘

Byte 0 (raw[0]): Status & Quality
┌───────┬───┬───┐
│Quality│Inv│New│
│ 6bit  │1b │1b │
└───────┴───┴───┘
   ↑      ↑   ↑
   │      │   └─ new_scan: 새 회전 시작 플래그
   │      └───── inversed_new_scan: 검증용
   └──────────── quality: 레이저 반사 강도 (0~63)

Byte 1 (raw[1]): Angle Low 7bit + Check bit
┌──────────┬───┐
│Angle_Low │Chk│
│  7bit    │1b │
└──────────┴───┘
   ↑         ↑
   │         └─ check_bit: 항상 1이어야 함
   └─────────── 각도 하위 7비트

Byte 2 (raw[2]): Angle High 8bit
┌─────────────┐
│ Angle_High  │
│    8bit     │
└─────────────┘
   ↑
   └─────────── 각도 상위 8비트

Byte 3-4 (raw[3], raw[4]): Distance (16bit, Little Endian)
┌──────────┬───────────┐
│Dist_Low  │ Dist_High │
│  8bit    │   8bit    │
└──────────┴───────────┘
   ↑          ↑
   └──────────┴─────── 거리 (mm 단위)


   ##Angle 계산식
   angle = ((raw[1] >> 1) + (raw[2] << 7)) / 64.0
```

#### **왜 이런 식일까?**

**프로토콜 사양:**
- 각도 범위: 0° ~ 360°
- 분해능: 0.015625° (1/64도)
- 저장 형식: 15비트 정수 (0 ~ 32767)

**각도 인코딩:**
```
실제 각도 = 정수 값 ÷ 64

예시:
- 0도   → 0 ÷ 64 = 0.0
- 90도  → 5760 ÷ 64 = 90.0
- 180도 → 11520 ÷ 64 = 180.0
- 360도 → 23040 ÷ 64 = 360.0
```

**15비트를 2바이트에 나눠 저장:**
```
15비트 정수 = [8비트 high] [7비트 low]

┌──────────────┬─────────────┐
│ raw[2] (8bit)│raw[1]의 상위 7bit│
└──────────────┴─────────────┘
      ↓               ↓
   High × 128    +   Low
```

**왜 raw[1]을 >> 1 할까?**
```
raw[1] = [Angle_Low 7bit][Check_bit 1bit]
           ↑                    ↑
         필요함              버려야 함

raw[1] >> 1  →  check_bit 제거하고 Angle_Low만 추출